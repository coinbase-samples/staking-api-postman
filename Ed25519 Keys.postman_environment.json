{
  "id": "418a05a2-b7a7-4c64-835b-7ea1f40cfc72",
  "name": "Ed25519 Keys",
  "values": [
    {
      "key": "name",
      "value": "SET_ME",
      "type": "secret",
      "enabled": true
    },
    {
      "key": "privateKey",
      "value": "SET_ME",
      "type": "secret",
      "enabled": true
    },
    {
      "key": "noble_ed25519",
      "value": "/**\n * Minified by jsDelivr using Terser v5.37.0.\n * Original file: /npm/noble-ed25519@1.2.6/index.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\n\"use strict\";\n/*! noble-ed25519 - MIT License (c) Paul Miller (paulmillr.com) */Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.utils=exports.verify=exports.sign=exports.getPublicKey=exports.SignResult=exports.Signature=exports.Point=exports.ExtendedPoint=exports.CURVE=void 0;const CURVE={a:-1n,d:37095705934669439343138083508754565189542113879843219016388785533085940283555n,P:2n**255n-19n,n:2n**252n+27742317777372353535851937790883648493n,h:8n,Gx:15112221349535400772501151409588531511454012693041857206046113283949847762202n,Gy:46316835694926478169428394003475163141307993866256225615783033603165251855960n};exports.CURVE=CURVE;const B32=32,SQRT_M1=19681161376707505956807079304988542015446066515923890162744021073123829784752n,SQRT_AD_MINUS_ONE=25063068953384623474111414158702152701244531502492656460079210482610430750235n,INVSQRT_A_MINUS_D=54469307008909316920995813868745141605393597292927456921205312896311721017578n,ONE_MINUS_D_SQ=1159843021668779879193775521855586647937357759715417654439879720876111806838n,D_MINUS_ONE_SQ=40440834346308536858101042469323190826248399146238708352240133220865137265952n;class ExtendedPoint{constructor(t,e,n,o){this.x=t,this.y=e,this.z=n,this.t=o}static fromAffine(t){if(!(t instanceof Point))throw new TypeError(\"ExtendedPoint#fromAffine: expected Point\");return t.equals(Point.ZERO)?ExtendedPoint.ZERO:new ExtendedPoint(t.x,t.y,1n,mod(t.x*t.y))}static toAffineBatch(t){const e=invertBatch(t.map((t=>t.z)));return t.map(((t,n)=>t.toAffine(e[n])))}static normalizeZ(t){return this.toAffineBatch(t).map(this.fromAffine)}static fromRistrettoHash(t){const e=bytes255ToNumberLE(t.slice(0,32)),n=this.calcElligatorRistrettoMap(e),o=bytes255ToNumberLE(t.slice(32,64)),r=this.calcElligatorRistrettoMap(o);return n.add(r)}static calcElligatorRistrettoMap(t){const{d:e}=CURVE,n=mod(SQRT_M1*t*t),o=mod((n+1n)*ONE_MINUS_D_SQ);let r=-1n;const i=mod((r-e*n)*mod(n+e));let{isValid:s,value:d}=uvRatio(o,i),f=mod(d*t);edIsNegative(f)||(f=mod(-f)),s||(d=f),s||(r=n);const a=mod(r*(n-1n)*D_MINUS_ONE_SQ-i),u=d*d,c=mod((d+d)*i),m=mod(a*SQRT_AD_MINUS_ONE),y=mod(1n-u),l=mod(1n+u);return new ExtendedPoint(mod(c*l),mod(y*m),mod(m*l),mod(c*y))}static fromRistrettoBytes(t){const{a:e,d:n}=CURVE,o=\"ExtendedPoint.fromRistrettoBytes: Cannot convert bytes to Ristretto Point\",r=bytes255ToNumberLE(t);if(!equalBytes(numberToBytesPadded(r,32),t)||edIsNegative(r))throw new Error(o);const i=mod(r*r),s=mod(1n+e*i),d=mod(1n-e*i),f=mod(s*s),a=mod(d*d),u=mod(e*n*f-a),{isValid:c,value:m}=invertSqrt(mod(u*a)),y=mod(m*d),l=mod(m*y*u);let p=mod((r+r)*y);edIsNegative(p)&&(p=mod(-p));const h=mod(s*l),E=mod(p*h);if(!c||edIsNegative(E)||0n===h)throw new Error(o);return new ExtendedPoint(p,h,1n,E)}toRistrettoBytes(){let{x:t,y:e,z:n,t:o}=this;const r=mod((n+e)*(n-e)),i=mod(t*e),{value:s}=invertSqrt(mod(r*i**2n)),d=mod(s*r),f=mod(s*i),a=mod(d*f*o);let u;edIsNegative(o*a)?([t,e]=[mod(e*SQRT_M1),mod(t*SQRT_M1)],u=mod(d*INVSQRT_A_MINUS_D)):u=f,edIsNegative(t*a)&&(e=mod(-e));let c=mod((n-e)*u);return edIsNegative(c)&&(c=mod(-c)),numberToBytesPadded(c,32)}equals(t){const e=t,[n,o,r,i]=[this.t,e.t,this.z,e.z];return mod(n*i)===mod(o*r)}negate(){return new ExtendedPoint(mod(-this.x),this.y,this.z,mod(-this.t))}double(){const t=this.x,e=this.y,n=this.z,{a:o}=CURVE,r=mod(t**2n),i=mod(e**2n),s=mod(2n*n**2n),d=mod(o*r),f=mod((t+e)**2n-r-i),a=mod(d+i),u=mod(a-s),c=mod(d-i),m=mod(f*u),y=mod(a*c),l=mod(f*c),p=mod(u*a);return new ExtendedPoint(m,y,p,l)}add(t){const e=this.x,n=this.y,o=this.z,r=this.t,i=t.x,s=t.y,d=t.z,f=t.t,a=mod((n-e)*(s+i)),u=mod((n+e)*(s-i)),c=mod(u-a);if(0n===c)return this.double();const m=mod(2n*o*f),y=mod(2n*r*d),l=mod(y+m),p=mod(u+a),h=mod(y-m),E=mod(l*c),w=mod(p*h),x=mod(l*h),P=mod(c*p);return new ExtendedPoint(E,w,P,x)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){if(!isValidScalar(t))throw new TypeError(\"Point#multiply: expected number or bigint\");let e=mod(BigInt(t),CURVE.n);if(1n===e)return this;let n=ExtendedPoint.ZERO,o=this;for(;e>0n;)1n&e&&(n=n.add(o)),o=o.double(),e>>=1n;return n}precomputeWindow(t){const e=256/t+1;let n=[],o=this,r=o;for(let i=0;i<e;i++){r=o,n.push(r);for(let e=1;e<2**(t-1);e++)r=r.add(o),n.push(r);o=r.double()}return n}wNAF(t,e){!e&&this.equals(ExtendedPoint.BASE)&&(e=Point.BASE);const n=e&&e._WINDOW_SIZE||1;if(256%n)throw new Error(\"Point#wNAF: Invalid precomputation window, must be power of 2\");let o=e&&pointPrecomputes.get(e);o||(o=this.precomputeWindow(n),e&&1!==n&&(o=ExtendedPoint.normalizeZ(o),pointPrecomputes.set(e,o)));let r=ExtendedPoint.ZERO,i=ExtendedPoint.ZERO;const s=256/n+1,d=2**(n-1),f=BigInt(2**n-1),a=2**n,u=BigInt(n);for(let e=0;e<s;e++){const n=e*d;let s=Number(t&f);if(t>>=u,s>d&&(s-=a,t+=1n),0===s)i=i.add(e%2?o[n].negate():o[n]);else{const t=o[n+Math.abs(s)-1];r=r.add(s<0?t.negate():t)}}return[r,i]}multiply(t,e){if(!isValidScalar(t))throw new TypeError(\"Point#multiply: expected number or bigint\");const n=mod(BigInt(t),CURVE.n);return ExtendedPoint.normalizeZ(this.wNAF(n,e))[0]}toAffine(t=invert(this.z)){const e=mod(this.x*t),n=mod(this.y*t);return new Point(e,n)}}exports.ExtendedPoint=ExtendedPoint,ExtendedPoint.BASE=new ExtendedPoint(CURVE.Gx,CURVE.Gy,1n,mod(CURVE.Gx*CURVE.Gy)),ExtendedPoint.ZERO=new ExtendedPoint(0n,1n,1n,0n);const pointPrecomputes=new WeakMap;class Point{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,pointPrecomputes.delete(this)}static fromHex(t){const{d:e,P:n}=CURVE,o=t instanceof Uint8Array?t:hexToBytes(t);if(32!==o.length)throw new Error(\"Point.fromHex: expected 32 bytes\");const r=o[31],i=-129&r,s=!!(128&r),d=bytesToNumberLE(Uint8Array.from(Array.from(o.slice(0,31)).concat(i)));if(d>=n)throw new Error(\"Point.fromHex expects hex <= Fp\");const f=mod(d*d),a=mod(f-1n),u=mod(e*f+1n);let{isValid:c,value:m}=uvRatio(a,u);if(!c)throw new Error(\"Point.fromHex: invalid y coordinate\");return s!==(1n===(1n&m))&&(m=mod(-m)),new Point(m,d)}static async fromPrivateKey(t){const e=await exports.utils.sha512(normalizePrivateKey(t));return Point.BASE.multiply(encodePrivate(e))}toRawBytes(){const t=numberToHex(this.y),e=new Uint8Array(32);for(let n=t.length-2,o=0;o<32&&n>=0;n-=2,o++)e[o]=Number.parseInt(t[n]+t[n+1],16);const n=1n&this.x?128:0;return e[31]|=n,e}toHex(){return bytesToHex(this.toRawBytes())}toX25519(){return mod((1n+this.y)*invert(1n-this.y))}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new Point(mod(-this.x),this.y)}add(t){return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return ExtendedPoint.fromAffine(this).multiply(t,this).toAffine()}}exports.Point=Point,Point.BASE=new Point(CURVE.Gx,CURVE.Gy),Point.ZERO=new Point(0n,1n);class Signature{constructor(t,e){this.r=t,this.s=e}static fromHex(t){t=ensureBytes(t);const e=Point.fromHex(t.slice(0,32)),n=bytesToNumberLE(t.slice(32));if(!isWithinCurveOrder(n))throw new Error(\"Signature.fromHex expects s <= CURVE.n\");return new Signature(e,n)}toRawBytes(){const t=hexToBytes(numberToHex(this.s)).reverse(),e=new Uint8Array(32);e.set(t);const n=new Uint8Array(64);return n.set(this.r.toRawBytes()),n.set(e,32),n}toHex(){return bytesToHex(this.toRawBytes())}}function concatBytes(...t){if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),n=new Uint8Array(e);for(let e=0,o=0;e<t.length;e++){const r=t[e];n.set(r,o),o+=r.length}return n}function bytesToHex(t){let e=\"\";for(let n=0;n<t.length;n++)e+=t[n].toString(16).padStart(2,\"0\");return e}function hexToBytes(t){if(\"string\"!=typeof t)throw new TypeError(\"hexToBytes: expected string, got \"+typeof t);if(t.length%2)throw new Error(\"hexToBytes: received invalid unpadded hex\");const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const o=2*n;e[n]=Number.parseInt(t.slice(o,o+2),16)}return e}function numberToHex(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function numberToBytesPadded(t,e=32){return hexToBytes(numberToHex(t).padStart(2*e,\"0\")).reverse()}function edIsNegative(t){return 1n===(1n&mod(t))}function isValidScalar(t){return\"bigint\"==typeof t&&t>0n||!!(\"number\"==typeof t&&t>0&&Number.isSafeInteger(t))}function bytesToNumberLE(t){let e=0n;for(let n=0;n<t.length;n++)e+=BigInt(t[n])<<8n*BigInt(n);return e}function bytes255ToNumberLE(t){return mod(bytesToNumberLE(t)&2n**255n-1n)}function mod(t,e=CURVE.P){const n=t%e;return n>=0n?n:e+n}function invert(t,e=CURVE.P){if(0n===t||e<=0n)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=mod(t,e),o=e,[r,i,s,d]=[0n,1n,1n,0n];for(;0n!==n;){const t=o/n,e=o%n,f=r-s*t,a=i-d*t;[o,n]=[n,e],[r,i]=[s,d],[s,d]=[f,a]}if(1n!==o)throw new Error(\"invert: does not exist\");return mod(r,e)}function invertBatch(t,e=CURVE.P){const n=t.length,o=new Array(n);let r=1n;for(let i=0;i<n;i++)0n!==t[i]&&(o[i]=r,r=mod(r*t[i],e));r=invert(r,e);for(let i=n-1;i>=0;i--){if(0n===t[i])continue;let n=mod(r*t[i],e);t[i]=mod(r*o[i],e),r=n}return t}function pow2(t,e){const{P:n}=CURVE;let o=t;for(;e-- >0n;)o*=o,o%=n;return o}function pow_2_252_3(t){const{P:e}=CURVE,n=t*t%e*t%e,o=pow2(n,2n)*n%e,r=pow2(o,1n)*t%e,i=pow2(r,5n)*r%e,s=pow2(i,10n)*i%e,d=pow2(s,20n)*s%e,f=pow2(d,40n)*d%e,a=pow2(f,80n)*f%e,u=pow2(a,80n)*f%e,c=pow2(u,10n)*i%e;return pow2(c,2n)*t%e}function uvRatio(t,e){const n=mod(e*e*e),o=mod(n*n*e);let r=mod(t*n*pow_2_252_3(t*o));const i=mod(e*r*r),s=r,d=mod(r*SQRT_M1),f=i===t,a=i===mod(-t),u=i===mod(-t*SQRT_M1);return f&&(r=s),(a||u)&&(r=d),edIsNegative(r)&&(r=mod(-r)),{isValid:f||a,value:r}}function invertSqrt(t){return uvRatio(1n,t)}async function sha512ToNumberLE(...t){const e=concatBytes(...t);return mod(bytesToNumberLE(await exports.utils.sha512(e)),CURVE.n)}function keyPrefix(t){return t.slice(32)}function encodePrivate(t){const e=t.slice(0,32);return e[0]&=248,e[31]&=127,e[31]|=64,mod(bytesToNumberLE(e),CURVE.n)}function equalBytes(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function ensureBytes(t){return t instanceof Uint8Array?t:hexToBytes(t)}function isWithinCurveOrder(t){return 0<t&&t<CURVE.n}function normalizePrivateKey(t){let e;if(\"bigint\"==typeof t||\"number\"==typeof t&&Number.isSafeInteger(t)){if(e=BigInt(t),e<0n||e>2n**256n)throw new Error(\"Expected 32 bytes of private key\");t=e.toString(16).padStart(64,\"0\")}if(\"string\"==typeof t){if(64!==t.length)throw new Error(\"Expected 32 bytes of private key\");return hexToBytes(t)}if(t instanceof Uint8Array){if(32!==t.length)throw new Error(\"Expected 32 bytes of private key\");return t}throw new TypeError(\"Expected valid private key\")}async function getPublicKey(t){const e=await Point.fromPrivateKey(t);return\"string\"==typeof t?e.toHex():e.toRawBytes()}async function sign(t,e){const n=await exports.utils.sha512(normalizePrivateKey(e)),o=encodePrivate(n),r=Point.BASE.multiply(o),i=ensureBytes(t),s=await sha512ToNumberLE(keyPrefix(n),i),d=Point.BASE.multiply(s),f=mod(s+await sha512ToNumberLE(d.toRawBytes(),r.toRawBytes(),i)*o,CURVE.n),a=new Signature(d,f);return\"string\"==typeof t?a.toHex():a.toRawBytes()}async function verify(t,e,n){e=ensureBytes(e),n instanceof Point||(n=Point.fromHex(n)),t instanceof Signature||(t=Signature.fromHex(t));const o=await sha512ToNumberLE(t.r.toRawBytes(),n.toRawBytes(),e),r=ExtendedPoint.fromAffine(n).multiplyUnsafe(o),i=ExtendedPoint.BASE.multiply(t.s);return ExtendedPoint.fromAffine(t.r).add(r).subtract(i).multiplyUnsafe(8n).equals(ExtendedPoint.ZERO)}exports.Signature=Signature,exports.SignResult=Signature,exports.getPublicKey=getPublicKey,exports.sign=sign,exports.verify=verify,Point.BASE._setWindowSize(8);const crypto=(()=>{const t=\"object\"==typeof self&&\"crypto\"in self?self.crypto:void 0,e=\"undefined\"!=typeof module&&\"function\"==typeof module.require&&module.require.bind(module);return{node:e&&!t?e(\"crypto\"):void 0,web:t}})();exports.utils={TORSION_SUBGROUP:[\"0100000000000000000000000000000000000000000000000000000000000000\",\"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a\",\"0000000000000000000000000000000000000000000000000000000000000080\",\"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05\",\"ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f\",\"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85\",\"0000000000000000000000000000000000000000000000000000000000000000\",\"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa\"],randomBytes:(t=32)=>{if(crypto.web)return crypto.web.getRandomValues(new Uint8Array(t));if(crypto.node){const{randomBytes:e}=crypto.node;return new Uint8Array(e(t).buffer)}throw new Error(\"The environment doesn't have randomBytes function\")},randomPrivateKey:()=>{let t=1024;for(;t--;){const t=exports.utils.randomBytes(32),e=bytesToNumberLE(t);if(e>1n&&e<CURVE.n)return t}throw new Error(\"Valid private key was not found in 1024 iterations. PRNG is broken\")},sha512:async t=>{if(crypto.web){const e=await crypto.web.subtle.digest(\"SHA-512\",t.buffer);return new Uint8Array(e)}if(crypto.node)return Uint8Array.from(crypto.node.createHash(\"sha512\").update(t).digest());throw new Error(\"The environment doesn't have sha512 function\")},precompute(t=8,e=Point.BASE){const n=e.equals(Point.BASE)?e:new Point(e.x,e.y);return n._setWindowSize(t),n.multiply(1n),n}};\n//# sourceMappingURL=/sm/b41be0e37c55800eb00f4285cb2b2b84e384dcfb0b521400fafd695c81fe72e3.map",
      "type": "default",
      "enabled": true
    },
    {
      "key": "token",
      "value": "",
      "type": "default",
      "enabled": true
    }
  ],
  "_postman_variable_scope": "environment",
  "_postman_exported_at": "2025-03-31T17:44:36.861Z",
  "_postman_exported_using": "Postman/11.38.4"
}
